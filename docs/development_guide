= Notes for developers

To get a copy of the development version, install bzr and use
bzr branch lp:chaos2010

You can browse the files online here (no syntax highlighting yet, sorry):
http://bazaar.launchpad.net/~jakewheat/chaos2010/trunk/files

changelog available here:
https://code.launchpad.net/~jakewheat/chaos2010/trunk

== Overview of architecture

Uses postgresql, haskell and gtk to run.

All data is stored in database tables except the png files for the
sprites, and the ogg files for the sound effects.

=== layers

The system has a loose layering (which in retrospect is pointlessly
overcomplicated):

application independent extensions to postgresql - system.sql

table definitions and all the code to actually run a game without a ui
  - server.sql

ui specific database tables and functions - client.sql

ui code - chaos.lhs, and other haskell files (most of the widgets have
a section in chaos.lhs and a section in client.sql)

For the most part, as much ui logic is pushed out of the haskell and
into client.sql

=== details

When playing the game, almost all updates to the database use db
stored procs (the exceptions are a few bits of code that update the ui
specific tables, like the new game widget).

The ui uses sql select statements to read the data from the database.

The ui attempts to be as declarative as possible.

Gtk & Cairo are used to draw the playing board, the rest of the
widgets use gtk text views.

SDL_mixer is used to play the sound effects.

The ui uses threads a lot to improve ui responsiveness, all database
updates fork a separate thread to run in, and all ui updates from the
database fork a thread to read the database and process it, and then
add a gtk idle handler to update the widgets themselves. This is all
done to minimise the amount of code executed within the gtk event
handler thread.

The automated tests are mostly written in haskell and are mostly
functional tests.

== Files

=== sql

system.sql          mainly an lightweight extended constraint system for
                    postgresql

server.sql          database implementation of the game, main relvars and
                    functions

client.sql          database stuff for ui and chaos.lhs

=== exes

chaos.lhs           implements the gtk ui using haskell, and front end to

ProcessProfile.lhs  parse the logs produced by the logging system and
                    creates a visualisation (needs a lot of work)
                    some utility functions

tests.lhs           automated tests using hunit

TreeThing.lhs       for developers, displays an outline of files and
                    sections, as well as the database relvars,
                    functions, etc.

=== other haskell files

BoardWidget.lhs     code to draw the board graphics and effects

ChaosDB.lhs         some simple wrappers around HDBC for database access

ChaosTypes.lhs      contains type definitions which are used by chaos.lhs
                    and boardwidget.lhs

Conf.lhs            reads ~/.chaos.config

DBAadmin.lhs        functions to load/reset the database from the sql scripts
                    for development and installation

FileAdmin.lhs       some file utils

GtkUtils.lhs        some gtk utils which are shared between programs

Logging.lhs         simple wrapper around hslogger, logging is currently used
                    for some basic profiling

MyTextView.lhs      some code to describe the contents of a
                    textview/textbuffer purely (including tags,
                    embedded widgets), code to render this to an
                    actual textview, and a few utility functions for
                    working with textviews

Paths_chaos.lhs     file to work with cabal data files system

Setup.lhs           for cabal builds

SoundLib.lhs        code to load and play sounds

ThreadingUtils.lhs  some util functions for the ui threading code

Utils.lhs           code utility functions

=== other files

chaos.cabal         cabal build file for the project

development_guide   this file, an overview of the source

LICENSE             license that this code is distributed under

README              overview, prerequisites, installation instructions,
                    playing instructions

todo                list of areas to work on and milestones

== more details

The code and comments uses/abuses a mixture of sql and proper
relational terminology, and also often incorrectly refers to
postgresql (pg) functions as stored procedures.

Most of the code to implement the game is written in pl/pgpsql. The ui
and most of the tests are written in haskell.

All the base relvars in the database are tagged as one of

* readonly: containing data which is updated only when creating the
  database from source and not when the game is being played

* data: holds data specific to the current game, including client/ ui
  stuff

* stack: tables to hold relvars which would be 'on the stack' if
  plpgsql supported this - either relvars local to a function, or
  relations passed as argument to a function. plpgsql does effectively
  support returning a relation from a function, so this is used
  directly. These relvars should always be empty outside a
  transaction.

All updates to the relvars use 'actions' which are the stored procs
which update the database. (The reason for this is that most of the
updates don't really map to straightforward relvar
inserts/updates/deletes, and not for some idealogical attachment to
only updating the database by stored procedures in this case.) No
database reads use stored procedures, only direct select statements
(mostly the complicated select statements are abstracted as views in
the database). Each action which can be called directly by the ui code
has an associated predicate which tests whether it is valid to run the
action at that time (analogous to database constraints).

Data integrity is maintained using transactions exclusively for
updates (you can't really see them in the code, every function
invocation in postgresql is in an implicit transaction), and by using
declarative constraints instead of imperative checks in the updates as
much as possible.

UI: The basic idea is to program it a series of select statements from
the database, the resultant widgets are then updated automatically
when the data changes, this used to rely on postgresql notify/listen,
which isn't supported in HDBC, so it doesn't yet work this way.

The game state and ui state persist independently of whether the game
is running or not, and changes are always saved instantly so crashes
almost never lose anything; when there is an error in the database
code, only the last transaction is lost.

== Getting started with the source code

data structures and then the game code: go through the read only data,
game data, turn sequence and then action sections in server.sql.

ui: start with chaos.lhs, starts with some notes on the ui design,
then look at the board widget, spellbook widget, and info widget
sections which should give you an idea of how the data from the
database is presented to the user. If you haven't looked at the data
structures and game code mentioned in the previous section you could
do that next, then follow the key press handling code path to see how
updates are triggered by the ui.

tests: see the tests in tests.lhs which are mostly kind of acceptance/
functional tests and may provide some useful examples of how the code
is used, e.g. to cast a spell or move a monster.
