
> module Games.Chaos2010.UI.NewGameWidget (newGameWidgetNew) where

> import Graphics.UI.Gtk hiding (disconnect)
>
> import Data.List
> import qualified Data.Char as DC
> import Control.Monad

> import Games.Chaos2010.Dbms.ChaosDB
> import Games.Chaos2010.Utils
> import Games.Chaos2010.UI.MyTextView as MyTextView
> import qualified Games.Chaos2010.UI.DBTextView as D
> import qualified Games.Chaos2010.Misc.Logging as Logging
> import Games.Chaos2010.ChaosTypes
> import Games.Chaos2010.Misc.ThreadingUtils
> import Games.Chaos2010.UI.UIThreadingUtils
> import Games.Chaos2010.UI.ChaosTextView

================================================================================

= New Game Widget

Starting new game involves the following choices:
number of wizards (2-8)
computer wizards same ai same stats as player
for each wizard:
    name text - autogenerated, can be changed
    computer_controlled bool
    sprite and colour displayed but cannot currently be changed

new game widget:
-------------------------------------------------------------
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
-------------------------------------------------------------

> newGameWidgetNew :: Connection ->
>                     ColourList ->
>                     SpriteMap ->
>                     IO (TextView, IO())
> newGameWidgetNew conn colours spriteMap = do
>   tv <- myTextViewNew colours
>   fk <- forkAndQueueOneNew
>   let refresh = lg "newGameWidgetNew.refresh" "" $
>         forkUpdate fk "newGameWidgetNew.refresh"
>           (do
>             --first check the new_game_widget_state relvar
>             c <- selectValue conn "select count(*) from new_game_widget_state" []
>             when (c == "0")
>                  (dbAction conn "reset_new_game_widget_state" [])
>             D.run conn (items refresh))
>           (\i -> do
>              buf <- textViewGetBuffer tv
>              textBufferClear buf
>              render tv i)
>   return (tv, refresh)
>     where

Fill in the rows which correspond to each wizard

>       items refresh =
>               [D.SelectTuples "select * from new_game_widget_state\n\
>                              \order by line" [] $ \l ->

draw our sprite for this wizard

>                 [sprite $ lk "sprite" l
>                 ,Text $ "\t" ++ lk "sprite_name" l ++ "\t"

create a helper function for adding radio buttons as part of a group
these are the buttons which set whether a wizard is human, android,
or not present

>                 ,ToggleButtonGroup ["human", "computer", "none"]
>                                    (lk "state" l)
>                                    (\label -> forkIt $ runSql conn
>                                             "update new_game_widget_state\n\
>                                             \set state =? where line =?"
>                                             [label, lk "line" l])
>                 ,Text "\n"
>                 ]

add the buttons at the bottom of the panel to start the game and
reset the panel

>               ,D.Items $ [MyTextView.Button "start game" $
>                             forkIt $ dbAction conn
>                                      "client_new_game_using_\
>                                      \new_game_widget_state" []
>                             --temp:
>                             --win <- getParentWidget tv
>                             --widgetHideAll win
>                          ,MyTextView.Button "reset this window" $ forkIt $ do
>                             dbAction conn "reset_new_game_widget_state" []
>                             refresh
>                          ,Text "\n"
>                          ] ++

add some temporary buttons to start custom games for testing purposes

>                           for ["all_pieces"
>                               ,"upgraded_wizards"
>                               ,"overlapping"
>                               ] (\l -> MyTextView.Button l $ forkIt $ do
>                                   dbAction conn
>                                            "client_new_game_using_\
>                                            \new_game_widget_state" []
>                                   dbAction conn "setup_test_board" [l])
>                                   -- need to call refresh all here somehow
>               ]
>       sprite s = let (pb,_,_) = safeMLookup ("show sprite " ++ s) s spriteMap
>                  in Pixbuf $ head pb

TODO: make this into a game manager which handles managing multiple
games and deleting ones you don't want, as well as starting new games


> lg :: String -> String -> IO c -> IO c
> lg l = Logging.pLog ("chaos.chaos." ++ l)
