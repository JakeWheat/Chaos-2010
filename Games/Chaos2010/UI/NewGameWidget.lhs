
= New Game Widget

Starting new game involves the following choices:
number of wizards (2-8)
computer wizards same ai same stats as player
for each wizard:
    name text - autogenerated, can be changed
    computer_controlled bool
    sprite and colour displayed but cannot currently be changed

new game widget:
-------------------------------------------------------------
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
|sprite | autogen name (editable) |radio:human computer none|
-------------------------------------------------------------

> {-# LANGUAGE ScopedTypeVariables #-}
> module Games.Chaos2010.UI.NewGameWidget where
>
> import Control.Applicative
> import Database.HaskellDB
> import Control.Monad as M

> import Games.Chaos2010.UI.UITypes
> import Games.Chaos2010.Database.New_game_widget_state
> import Games.Chaos2010.UI.HdbUtils
>
> newGameWidget :: (String -> [String] -> IO ()) -> DBText
> newGameWidget callSP =
>    DBText $ \db ->
>    let q t r = qdb db t r
>    in concat . concat <$> M.sequence [
>       q (do
>           t1 <- table new_game_widget_state
>           order [asc t1 line]
>           project $ copyAll t1)
>         (\r -> [Image $ "medium-" ++ r # sprite
>                ,Text $ "\t" ++ r # wizard_name ++ "\t"
>                ,ToggleButtonGroup [("human", "human")
>                                   ,("computer","computer")
>                                   ,("none", "none")]
>                                   (r # state)
>                                   (\x -> do
>                                     let (l::Int) = r # line
>                                     --   "update new_game_widget_state
>                                     --       \set state =? where line =?"
>                                     return ())
>                ,Text "\n"])
>      ,q (do
>          t1 <- table new_game_widget_state
>          project $ line .=. count(t1 .!. line)
>                 .*. emptyRecord)
>         (\_ -> [Button "start game" startGame
>                ,Button "reset this window" resetWidget
>                ,Text "\n"]
>          ++ flip map ["all_pieces"
>                      ,"upgraded_wizards"
>                      ,"overlapping"]
>                      (\lb -> Button lb (setupTestBoard lb )))]
>    where
>      startGame =  callSP "select action_client_new_game_using_new_game_widget_state();" []
>      resetWidget = callSP "select action_reset_new_game_widget_state();" []
>      setupTestBoard t = callSP "select action_setup_test_board(?);" [t]
